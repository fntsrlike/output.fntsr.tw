[{"_path":"/legacy-articles/2017-09-17-transaction-design-of-postgre-sql-and-my-sql","_dir":"legacy-articles","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"PostgreSQL 與 MySQL 關於 transaction 的設計理念","description":"","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"近日因為想要跳槽到 PostgreSQL，所以開始閱讀官方的參考文件。在讀到 "},{"type":"element","tag":"a","props":{"href":"https://www.postgresql.org/docs/9.6/static/tutorial-transactions.html","rel":["nofollow"]},"children":[{"type":"text","value":"3.4 Transactions"}]},{"type":"text","value":" 時，其中有一段不太能理解："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PostgreSQL actually treats every SQL statement as being executed within a transaction. If you do not issue a BEGIN command, then each individual statement has an implicit BEGIN and (if successful) COMMIT wrapped around it. A group of statements surrounded by BEGIN and COMMIT is sometimes called a transaction block."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因為以往對 transaction"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^1"}]},{"type":"text","value":"的了解不深，一直以為只會用在「我有數個 SQL 敘述，希望能夠其中一個失敗時，取消其他 SQL 敘述的執行」的情況，所以不太能理解「每個 SQL 敘述預設帶有一個 transaction」的設計，非常疑惑為什麼會需要將單個 SQL 敘述也用 transaction 包起來。所以就去請教了對 PostgreSQL 有經驗的 "},{"type":"element","tag":"a","props":{"href":"https://github.com/david50407","rel":["nofollow"]},"children":[{"type":"text","value":"@david50407"}]},{"type":"text","value":"。本篇文章大概就是在講述敝人向其請教後的理解。"}]},{"type":"element","tag":"h2","props":{"id":"基本觀念"},"children":[{"type":"text","value":"基本觀念"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PostgreSQL 參考手冊在 "},{"type":"element","tag":"a","props":{"href":"https://www.postgresql.org/docs/9.6/static/tutorial-transactions.html","rel":["nofollow"]},"children":[{"type":"text","value":"3.4 Transactions"}]},{"type":"text","value":" 的第一段，就以這樣的文字來敘述："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The essential point of a transaction is that it bundles multiple steps into a single, all-or-nothing operation. The intermediate states between the steps are not visible to other concurrent transactions, and if some failure occurs that prevents the transaction from completing, then none of the steps affect the database at all."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"該文字的意思大概就是，transaction 可以把 PostgeSQL 裡面多個敘述併成一個，並且遵從「全或無」（all-or-nothing）"},{"type":"element","tag":"sup","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#user-content-fn-2","ariaDescribedBy":"footnote-label","dataFootnoteRef":true,"id":"user-content-fnref-2"},"children":[{"type":"text","value":"1"}]}]},{"type":"text","value":" 的操作；也就是若在併成一個操作裡的諸多敘述，若有其中一個敘述出錯，其他成功的敘述也會被撤銷，就等同全部都沒有執行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這個功能比較常用的地方就在於金融業，常見的例子就是要避免 A 轉帳給 B 時，不能發生「扣了 A 的錢，但 B 那邊卻沒有增加」或是「對 A 扣錢失敗，但是 B 那邊的錢卻增加了」的情況，一定是要「扣了 A 的錢，也要加 B 的錢」，不然就是都不要發生。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在沒有特別處理的情況下，SQL 敘述大致如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-1"}]},{"type":"text","value":"：在沒有使用 transaction 的銀行交易情境示例"}]},{"type":"element","tag":"code","props":{"code":"UPDATE accounts SET deposit = deposit - 30000.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 30000.00 WHERE name = 'B';\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"UPDATE accounts SET deposit = deposit - 30000.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 30000.00 WHERE name = 'B';\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但若因為某種原因導致第一個敘述失敗，第二個敘述卻成功了，那麼銀行就會損失三萬元。若第一個敘述成功了，第二個敘述失敗，那顧客就會平白無故損失三萬元，導致銀行信譽掃地。所以在處理這類需要「全或無」的操作時，就必須將這些敘述宣告成一個 transaction block"},{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/904/#fn-904-transaction","rel":["nofollow"]},"children":[{"type":"text","value":"1"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"transaction block 的宣告方式，就是使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 兩個敘述，將多個需要綁定的 SQL 敘述給包起來，以上面的案例來改進，大致如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-2"}]},{"type":"text","value":"：使用 transaction 的銀行交易情境示例"}]},{"type":"element","tag":"code","props":{"code":"BEGIN;\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"BEGIN;\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若 transaction block 圍起來的敘述，只要有其中一個不成立，那麼 transaction block 裡的敘述就都不會被執行"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h2","props":{"id":"postgresql-關於-transaction-的設計理念"},"children":[{"type":"text","value":"PostgreSQL 關於 transaction 的設計理念"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"回到原本的疑問，在解惑之前先闡述一個 PostgreSQL 的基本概念："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PostgreSQL 一次只會執行一個原子級操作（atomic operation，意味這該項操作不可分割），PostgreSQL 只會在完成一次原子級操作才會將結果從記憶體寫入檔案，若是中間有任何衝突，就會重新從檔案讀取資料回記憶體覆蓋失敗的部分、進行還原。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"講到這邊，大概就能有點感覺。是的，transaction 就是 PostgreSQL 的原子級操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在沒有自行加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 語法的情況下，PostgreSQL 是不會把結果從記憶體存回硬碟，但是為了方便操作，PostgreSQL 預設會把沒有在 transaction block 中的 SQL 敘述外自動加入"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":"和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":"，也就是將該則敘述獨立視為一個 transaction block。如此才不用在編寫 SQL 敘述時，還有手動加上一對冗贅的 transaction 語法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-1"}]},{"type":"text","value":" 為例，雖然我們沒有幫他加上 transaction 語法，但是事實上它在執行時，是已經被 PostgreSQL 加入語法了，其真實的樣貌如下（"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 2-1"}]},{"type":"text","value":"）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 2-1"}]},{"type":"text","value":"：PostgreSQL transaction 預設行為示例"}]},{"type":"element","tag":"code","props":{"code":"-- 本段程式碼的 BEGIN; 和 COMMIT; 都是 PostgreSQL 自動加的\nBEGIN;  \nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nCOMMIT;\nBEGIN;\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-- 本段程式碼的 BEGIN; 和 COMMIT; 都是 PostgreSQL 自動加的\nBEGIN;  \nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nCOMMIT;\nBEGIN;\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以每項敘述都會是一個原子級操作，都被視為一個 transaction block，在成功完成後，才會寫入硬碟。若失敗則會跳下一個敘述繼續執行（這邊是假設匯入 SQL檔的情境，其他情境要視失敗時對例外地處理決策決定是中止操作還是繼續執行）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"從上面透過設計理念的理解，原本的問題也就豁然開朗。了解其背後理念和原因後，也可以繼續思考以下問題，讓自己對這份知識更加熟稔："}]},{"type":"element","tag":"h5","props":{"id":"問題一"},"children":[{"type":"text","value":"問題一"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"匯入一個 SQL 文件 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dump.sql"}]},{"type":"text","value":" 到 PostgreSQL 時，假設 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dump.sql"}]},{"type":"text","value":" 裡沒有任何 transaction 語法，並有 N 行敘述，而第 M 行敘述是會發生衝突的，那資料庫最後會有幾筆異動？"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n(A) N 筆（成功執行所有敘述）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n(B) N – 1 筆（成功執行除了第 M 行以外的敘述）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n(C) M – 1 筆（只成功執行第 M 行之前的敘述，第 M 行及其之後的敘述都被駁回）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n(D) 0 筆（全部敘述遭到駁回）"}]}]},{"type":"element","tag":"h5","props":{"id":"問題二"},"children":[{"type":"text","value":"問題二"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"承問題一，若答案不是 (D) 選項，那為什麼在一起匯入的情況下，不是所有敘述都被駁回，而是部分被套用？"}]}]},{"type":"element","tag":"h5","props":{"id":"問題三"},"children":[{"type":"text","value":"問題三"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"承問題二，那該怎麼做，才能讓匯入 SQL 文件到 PostgreSQL 時，是一有失敗就全部駁回，而不是部分套用呢？"}]}]},{"type":"element","tag":"h2","props":{"id":"與-mysql-比較"},"children":[{"type":"text","value":"與 MySQL 比較"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在略曉 PostgreSQL 關於 transaction 的設計後，在這節轉向探討 MySQL 關於 transaction 的設計。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MySQL 也是擁有 transaction 功能的，也定義了 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^4"}]},{"type":"text","value":"、"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT"}]},{"type":"text","value":" 語法。它也會預設對沒有在 transaction block 中的 SQL 敘述，進行預設的行為，那到底是哪邊跟 PostgreSQL 不同呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MySQL 的設計理念是在於，遇到 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 語法時，才會將資料從記憶體寫入硬碟，並且預設會對所有 SQL 敘述後自動在其後加上 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":"，在 MySQL 稱這項預設行為為自動提交（auto commit）。以"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-1"}]},{"type":"text","value":" 為例，在 MySQL 中其真實的樣貌如下（"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-1"}]},{"type":"text","value":"）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-1"}]},{"type":"text","value":"：MySQL auto commit 行為的示例"}]},{"type":"element","tag":"code","props":{"code":"-- 本段程式碼的 COMMIT; 都是 MySQL 自動加的\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nCOMMIT;\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-- 本段程式碼的 COMMIT; 都是 MySQL 自動加的\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nCOMMIT;\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 2-1"}]},{"type":"text","value":" 進行比較後，會發現 MySQL 在預設行為上，只會在敘述後加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 而不會在之前加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":"，這邊就顯示出兩者在設計概念上的不同。PostgreSQL 是以一個 transaction block 為一個單位作為 transaction 的操作；而 MySQL 則是以當下的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 到上一個 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 之間的敘述作為 transaction 的操作（準確來說，是指目前還沒被提交過的敘述）。而 MySQL 的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 就類似一個局部停用自動提交的語法，並作用到一個 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ROLLBACK;"}]},{"type":"text","value":" 語法為止，如"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-2"}]},{"type":"text","value":" 所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-2"}]},{"type":"text","value":"：MySQL BEGIN & COMMIT 示例"}]},{"type":"element","tag":"code","props":{"code":"BEGIN;\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"BEGIN;\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若是要在當前連線全域關閉這個自動動提交（auto commit）"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^5"}]},{"type":"text","value":"，可以透過 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"SET autocommit=0;"}]},{"type":"text","value":" 敘述，當 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"autocommit"}]},{"type":"text","value":" 設置為 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"0"}]},{"type":"text","value":" 時，就會停用自動提交。若將這功能停用時，就必須自己加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 以將之前執行成功且尚未提交過的敘述存入硬碟。與 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 不同，就算遇到 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":"，自動提交仍會保持停用，直到將 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"autocommit"}]},{"type":"text","value":" 設置為 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" 重啟這功能為止。同樣以"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-1"}]},{"type":"text","value":" 作為案例，大致如下（"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-3"}]},{"type":"text","value":"）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-3"}]},{"type":"text","value":"：MySQL autocommit 設置示例"}]},{"type":"element","tag":"code","props":{"code":"SET autocommit=0;\n\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT; -- COMMIT 並不會讓 autocommit 重新啟用\n\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'C';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'D';\nROLLBACK; -- ROLLBACK 也不會讓 autocommit 重新啟用\n\nSET autocommit=1; -- 只有將 autocommit 設置為 1 時，才會重啟自動提交的功能。\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"SET autocommit=0;\n\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT; -- COMMIT 並不會讓 autocommit 重新啟用\n\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'C';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'D';\nROLLBACK; -- ROLLBACK 也不會讓 autocommit 重新啟用\n\nSET autocommit=1; -- 只有將 autocommit 設置為 1 時，才會重啟自動提交的功能。\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了自動提交外，在 MySQL 參考手冊的 "},{"type":"element","tag":"a","props":{"href":"https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html","rel":["nofollow"]},"children":[{"type":"text","value":"13.3.3 Statements That Cause an Implicit Commit"}]},{"type":"text","value":" 有提到，當遇到修改資料表的敘述、資料定義語言（DDL）、或是 transactions 控制流程 "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^6"}]},{"type":"text","value":"和資料表鎖定相關的敘述時，在執行該敘述前，都會自動執行 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":"，也就是所謂的隱性提交（implicitly commit）"},{"type":"element","tag":"sup","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#user-content-fn-7","ariaDescribedBy":"footnote-label","dataFootnoteRef":true,"id":"user-content-fnref-7"},"children":[{"type":"text","value":"2"}]}]},{"type":"text","value":"。這部分可以參見"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-4"}]},{"type":"text","value":" 的示例加深理解。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-4"}]},{"type":"text","value":"：MySQL 隱性提交示例"}]},{"type":"element","tag":"code","props":{"code":"SET autocommit=0; -- 先停用自動提交\n\nINSERT INTO log (content) VALUES ('A');\n\nBEGIN; -- 執行此行敘述前，會進行隱性提交，導致前面的 SQL 敘述被存入硬碟。\nINSERT INTO log (content) VALUES ('B');\nCOMMIT;\n\nINSERT INTO log (content) VALUES ('C');\n\nSET autocommit=1; -- 執行此行敘述前，會進行隱性提交，導致前面的 SQL 敘述被存入硬碟。\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"SET autocommit=0; -- 先停用自動提交\n\nINSERT INTO log (content) VALUES ('A');\n\nBEGIN; -- 執行此行敘述前，會進行隱性提交，導致前面的 SQL 敘述被存入硬碟。\nINSERT INTO log (content) VALUES ('B');\nCOMMIT;\n\nINSERT INTO log (content) VALUES ('C');\n\nSET autocommit=1; -- 執行此行敘述前，會進行隱性提交，導致前面的 SQL 敘述被存入硬碟。\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這也導致了，MySQL 不能與 PostgreSQL 一般，進行 transactions 的嵌套（nested）"},{"type":"element","tag":"sup","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#user-content-fn-8","ariaDescribedBy":"footnote-label","dataFootnoteRef":true,"id":"user-content-fnref-8"},"children":[{"type":"text","value":"3"}]}]},{"type":"text","value":"，因為若在 transactions 裡又輸入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 時，這之前的 SQL 敘述就會先被 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 存入硬碟中。以下面程式碼（"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-5"}]},{"type":"text","value":"）為例，在 MySQL 中，"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"First"}]},{"type":"text","value":" 是會被存入資料表的，PostgreSQL 則不會。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-5"}]},{"type":"text","value":"：transactions 嵌套示例"}]},{"type":"element","tag":"code","props":{"code":"CREATE TABLE log (\n    content varchar(255)\n);\n\nBEGIN;\n    INSERT INTO log (content) VALUES ('First');\n\n    BEGIN;\n        INSERT INTO log (content) VALUES ('Second');\n        ROLLBACK;\n    COMMIT;\n\n    ROLLBACK;\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"CREATE TABLE log (\n    content varchar(255)\n);\n\nBEGIN;\n    INSERT INTO log (content) VALUES ('First');\n\n    BEGIN;\n        INSERT INTO log (content) VALUES ('Second');\n        ROLLBACK;\n    COMMIT;\n\n    ROLLBACK;\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"延伸應用"},"children":[{"type":"text","value":"延伸應用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，也因為 transaction 是在整個 transaction 完成且成功的情況下才會將資料寫入硬碟，不會如同一般情況是一個敘述寫入一次（事實上，一個敘述也等同一個 transaction。），所以若遇到需要執行大量敘述時，可以透過 transaction block 包覆起來，讓全部執行完後再一次寫入硬碟，節省對硬碟做 I/O 的時間，讓執行更加快。如"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 4-1"}]},{"type":"text","value":"："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 4-1"}]},{"type":"text","value":"：大量敘述搭配 transaction 以提升效率的示例"}]},{"type":"element","tag":"code","props":{"code":"BEGIN;\nINSERT INTO users (username, password) VALUES ('USERNAME_1', 'PASSWORD_1');\nINSERT INTO users (username, password) VALUES ('USERNAME_2', 'PASSWORD_2');\n-- ...\nINSERT INTO users (username, password) VALUES ('USERNAME_1000', 'PASSWORD_1000');\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"BEGIN;\nINSERT INTO users (username, password) VALUES ('USERNAME_1', 'PASSWORD_1');\nINSERT INTO users (username, password) VALUES ('USERNAME_2', 'PASSWORD_2');\n-- ...\nINSERT INTO users (username, password) VALUES ('USERNAME_1000', 'PASSWORD_1000');\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"結論"},"children":[{"type":"text","value":"結論"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文透過對 PostgreSQL 對每個單一敘述都使用 transaction block 包覆起來的設計，以及 transaction 代表從記憶體寫入硬碟這件事的認知，總算一解原先對該段敘述的疑惑。也透過比較 MySQL 相對應的功能的設計，更深入了解 transaction 運作上的差異。有了這些概念，日後在兩套資料庫系統交互使用時，就能避免踩到地雷了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最後，也感謝 "},{"type":"element","tag":"a","props":{"href":"https://github.com/david50407","rel":["nofollow"]},"children":[{"type":"text","value":"@david50407"}]},{"type":"text","value":" 對這相關議題的講解以及 "},{"type":"element","tag":"a","props":{"href":"https://github.com/TEMU1086","rel":["nofollow"]},"children":[{"type":"text","value":"@JasonWu"}]},{"type":"text","value":" 的共同討論。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^1"}]},{"type":"text","value":" transaction 通常在中文會翻譯成「交易」，但為了突顯其為本文探討的核心，在本文就不翻譯了。transaction block 亦同。"}]},{"type":"element","tag":"section","props":{"className":["footnotes"],"dataFootnotes":true},"children":[{"type":"element","tag":"h2","props":{"id":"footnote-label","className":["sr-only"]},"children":[{"type":"text","value":"Footnotes"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{"id":"user-content-fn-2"},"children":[{"type":"text","value":"all-or-nothing 直譯就是「全有或全無」，社群多是直接使用原文為主。另外搜尋到的中山資管所"},{"type":"element","tag":"a","props":{"href":"https://www.mis.nsysu.edu.tw/~syhwang/Courses/DB/manuscript.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"資料庫系統專題課程講義"}]},{"type":"text","value":"裡面則是加註「完整的執行完畢或保持原狀都不做」。這邊為了突顯其專有名詞的意涵，刻意翻成比較文言的「全或無」，其他類似翻譯可以參照國家研究院的"},{"type":"element","tag":"a","props":{"href":"http://terms.naer.edu.tw/detail/1304408/","rel":["nofollow"]},"children":[{"type":"text","value":"雙語詞彙資訊網"}]},{"type":"text","value":"；另有「悉無律」的翻譯，但這個詞似乎比較常作為漢字在日文中使用。這方面的翻譯多用在生物學的神經衝動現象上。（我和朋友都戲稱這叫老鼠屎原則，因為只要有敘述裡如有一顆老鼠屎的錯誤發生，就得將代表整鍋粥的 transaction block 全部丟掉。比較風雅一點的戲稱就是「鼠糞原則」。）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^3"}]},{"type":"text","value":" PostgreSQL 在 transaction block 中，若遇到錯誤，會自動丟出 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ROLLBACK;"}]},{"type":"text","value":"。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^4"}]},{"type":"text","value":" MySQL 預設是使用 SQL 標準的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"START TRANSACTION;"}]},{"type":"text","value":"作為 transaction 起始的宣告語法，但也支援 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 作為同義語法。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^5"}]},{"type":"text","value":" MySQL 在當前連線停用自動提交功能，並不會導致其他連線的自動提交也被停用。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^6"}]},{"type":"text","value":" MySQL 會造成隱性提交（implicit commit）的語法："},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"LOCK TABLES"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"SET autocommit = 1"}]},{"type":"text","value":" (若原本不等於 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":"時), "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"START TRANSACTION"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"UNLOCK TABLES"}]},{"type":"text","value":". "},{"type":"element","tag":"a","props":{"href":"#user-content-fnref-2","ariaLabel":"Back to content","className":["data-footnote-backref"],"dataFootnoteBackref":true},"children":[{"type":"text","value":"↩"}]}]},{"type":"element","tag":"li","props":{"id":"user-content-fn-7"},"children":[{"type":"element","tag":"a","props":{"href":"https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html","rel":["nofollow"]},"children":[{"type":"text","value":"MySQL Ref 13.3.3"}]},{"type":"text","value":": The statements listed in this section (and any synonyms for them) implicitly end any transaction active in the current session, as if you had done a COMMIT before executing the statement. "},{"type":"element","tag":"a","props":{"href":"#user-content-fnref-7","ariaLabel":"Back to content","className":["data-footnote-backref"],"dataFootnoteBackref":true},"children":[{"type":"text","value":"↩"}]}]},{"type":"element","tag":"li","props":{"id":"user-content-fn-8"},"children":[{"type":"element","tag":"a","props":{"href":"https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html","rel":["nofollow"]},"children":[{"type":"text","value":"MySQL Ref 13.3.3"}]},{"type":"text","value":": Transactions cannot be nested. This is a consequence of the implicit commit performed for any current transaction when you issue a START TRANSACTION statement or one of its synonyms.  "},{"type":"element","tag":"a","props":{"href":"#user-content-fnref-8","ariaLabel":"Back to content","className":["data-footnote-backref"],"dataFootnoteBackref":true},"children":[{"type":"text","value":"↩"}]}]}]}]}]},"title_en":"Transaction Design of PostgreSQL & MySQL","slug":"transaction-design-of-postgre-sql-and-my-sql","aliases":["PostgreSQL 與 MySQL 關於 transaction 的設計理念","Transaction Design of PostgreSQL & MySQL"],"created_at":"2017-09-17T10:41:53.000Z","published_at":null,"updated_at":null,"tags":["database","mysql","postgresql"],"moc":["Information Technology"],"_type":"markdown","_id":"garden:legacy-articles:2017-09-17-transaction-design-of-postgre-sql-and-my-sql.md","_source":"garden","_file":"legacy-articles/2017-09-17-transaction-design-of-postgre-sql-and-my-sql.md","_extension":"md"},{"_path":"/legacy-articles/2017-09-25-aoe-ii-rmsg-ch-1-language-reference","_dir":"legacy-articles","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"世紀帝國 II 系列：《隨機地圖腳本指南》CH1 語言","description":"","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文件譯自 "},{"type":"element","tag":"a","props":{"href":"http://aok.heavengames.com/blacksmith/showprofile.php?author=Bultro","rel":["nofollow"]},"children":[{"type":"text","value":"Bultro"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"a","props":{"href":"https://steamcommunity.com/id/zetnus","rel":["nofollow"]},"children":[{"type":"text","value":"Zetnus"}]},{"type":"text","value":" 所編寫的"},{"type":"element","tag":"a","props":{"href":"http://aok.heavengames.com/cgi-bin/forums/display.cgi?action=ct&f=28,42485,0,365","rel":["nofollow"]},"children":[{"type":"text","value":"《Updated New RMS Guide (v2.0.0)》"}]},{"type":"text","value":"，並取得作者同意以標示名稱為翻譯授權。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文章主要在講述腳本基礎架構，以及在編寫時應注意的細節。"}]},{"type":"element","tag":"h2","props":{"id":"正文"},"children":[{"type":"text","value":"正文"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"腳本 (scripts) 共分為七個章節（section），各章節專職一種地圖特徵（feature）。章節透過下列標籤 (tags) 的宣告作為起始："}]},{"type":"element","tag":"table","props":{},"children":[{"type":"element","tag":"thead","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"th","props":{"align":null},"children":[{"type":"text","value":"Chapter Name"}]},{"type":"element","tag":"th","props":{"align":null},"children":[{"type":"text","value":"Description"}]}]}]},{"type":"element","tag":"tbody","props":{},"children":[{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"<PLAYER_SETUP>"}]}]},{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"text","value":"基本設定"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"<LAND_GENERATION>"}]}]},{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"text","value":"土地設定，主要土地 (lands) 或海洋 (sea)"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"<ELEVATION_GENERATION>"}]}]},{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"text","value":"山丘 (Hills)"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"<CLIFF_GENERATION>"}]}]},{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"text","value":"峭壁 (Rocky cliffs)"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"<TERRAIN_GENERATION>"}]}]},{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"text","value":"地形 (Terrain)"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"<CONNECTION_GENERATION>"}]}]},{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"text","value":"連接地形，像是道路、橋"}]}]},{"type":"element","tag":"tr","props":{},"children":[{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"<OBJECTS_GENERATION>"}]}]},{"type":"element","tag":"td","props":{"align":null},"children":[{"type":"text","value":"單位、建築、資源、無用途的裝飾物件（放好看的）"}]}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"表 1：章節起始宣告關鍵字一覧"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"你可能會注意到遊戲內建的標準地圖在峭壁和連接地形的章節有不同的順序（有時包括海拔的章節）。然而，依照上面的順序去編寫，會讓你對地圖產生程序的想像以及了解發生了什麼事有所幫助。像是水可能會生成在山丘上、物件會被放置在連接地形上、或是為什麼地形可以避開峭壁等細節，這些都跟地圖在各特徵產生的順序有所關係。但無論如何，你編寫章節的順序都不會讓對地圖的產生造成差異。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不是所有章節都是需要的（像是你可以建立一個沒有峭壁的地形）。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"每個章節都會有不同種類的指令 (instructions) "},{"type":"element","tag":"sup","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#user-content-fn-1","ariaDescribedBy":"footnote-label","dataFootnoteRef":true,"id":"user-content-fnref-1"},"children":[{"type":"text","value":"1"}]}]},{"type":"text","value":"，多數的指令大概像是這樣："}]}]},{"type":"element","tag":"code","props":{"code":"create_something WHAT\n{\n    attribute TYPE\n    attribute N\n    set_attribute\n    ...\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"create_something WHAT\n{\n    attribute TYPE\n    attribute N\n    set_attribute\n    ...\n}\n"}]}]}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"在編寫腳本時，你可以隨你所欲的對指令內容進行縮排。只要將關鍵字透過換行（new line）或空白 (space) 進行分隔即可。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"腳本的關鍵字與常數名稱對大小寫敏感，請注意字母的大小寫。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"所有 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"create"}]},{"type":"text","value":" 命令都是可以使用多次的，其他命令則只能使用一次。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"多數屬性 (attributes)（也就是在大括號裡的次要命令(subcommands)）都會有預設值，不用特地寫出來。所以在有些時候，大括號 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"{ }"}]},{"type":"text","value":" 中是可以留白的！"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"大括號裡屬性的順序也是不重要的，其排序對地圖的產生沒有影響。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"如果有項目因為某些原因無法被建立，那遊戲程式會直接忽略它並繼續往下讀取。如果你發現有東西不見了，請嘗試稍微放寬其放置的限制 (constraints)。"}]}]},{"type":"element","tag":"h2","props":{"id":"筆記摘要"},"children":[{"type":"text","value":"筆記、摘要"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"七個章節：玩家、土地、海拔、峭壁、地形、連接、物件。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"程式會照順序讀取章節並逐一生成地圖特徵。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"腳本章節編寫順序不影響地圖生成；指令內屬性順序不影響生成效果。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"關鍵字和常數大小寫敏感。"}]}]},{"type":"element","tag":"section","props":{"className":["footnotes"],"dataFootnotes":true},"children":[{"type":"element","tag":"h2","props":{"id":"footnote-label","className":["sr-only"]},"children":[{"type":"text","value":"Footnotes"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{"id":"user-content-fn-1"},"children":[{"type":"text","value":"本系列文把 instructions 翻譯為指令，command 翻譯為命令。兩者不同之處為指令是有附帶資訊、敘述的，針對一個命令再加以說明，也就是大括號裡的屬性（attributes）；而命令則只是單純透過腳本要求地圖產生程序去做什麼事，除了基本參數外，沒有再附加屬性。簡而言之，在本文中，指令可視為一個命令再附加屬性，指令算是命令的一種。另外，關於英文中 instructions 與 command 的差異，有興趣的可以參見這篇簡短說明："},{"type":"element","tag":"a","props":{"href":"http://wikidiff.com/command/instruction","rel":["nofollow"]},"children":[{"type":"text","value":"〈Command vs Instruction – What’s the difference?〉。"}]},{"type":"text","value":"  "},{"type":"element","tag":"a","props":{"href":"#user-content-fnref-1","ariaLabel":"Back to content","className":["data-footnote-backref"],"dataFootnoteBackref":true},"children":[{"type":"text","value":"↩"}]}]}]}]}]},"title_en":"AOE II: RMSG CH1 - Language Reference","slug":"aoe-ii-rmsg-ch-1-language-reference","aliases":["世紀帝國 II 系列：《隨機地圖腳本指南》CH1 語言","AOE II: RMSG CH1 - Language Reference"],"created_at":"2017-09-25T14:18:43.000Z","published_at":null,"updated_at":null,"tags":["aoe","random-map-script","rmsg","traslation"],"moc":["Games"],"_type":"markdown","_id":"garden:legacy-articles:2017-09-25-aoe-ii-rmsg-ch-1-language-reference.md","_source":"garden","_file":"legacy-articles/2017-09-25-aoe-ii-rmsg-ch-1-language-reference.md","_extension":"md"}]