[{"_path":"/legacy-articles/2016-02-21-my-sql-utf-8-mb-4-breaks-active-record-schema-setup","_dir":"legacy-articles","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"解決 MySQL 使用 utf8mb4 編碼導致 Rails 資料庫遷移失敗的問題","description":"","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/293/","rel":["nofollow"]},"children":[{"type":"text","value":"解決 MySQL 使用 utf8mb4 編碼導致 Rails 資料庫遷移失敗的問題 - 深藏若虛"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當 MySQL 使用 utf8mb4 編碼，會導致 Rails 資料庫遷移失敗，並輸出此錯誤訊息的問題："}]},{"type":"element","tag":"code","props":{"code":"~/app $ RAILS_ENV=production rake db:migrate\n\n== 20150226092347 DeviseCreateUsers: migrating================================\n-- create_table(:users)\n   -> 0.0070s\n-- add_index(:users, :email, {:unique=>true})\nrake aborted!\nStandardError: An error has occurred, all later migrations canceled:\n\nMysql2::Error: Specified key was too long; max key length is 767 bytes: CREATE UNIQUE INDEX `index_users_on_email`  ON `users` (`email`) ~/.rvm/gems/ruby-2.2.2/gems/mysql2-0.4.2/lib/mysql2/client.rb:107:in `_query'\n......\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"~/app $ RAILS_ENV=production rake db:migrate\n\n== 20150226092347 DeviseCreateUsers: migrating================================\n-- create_table(:users)\n   -> 0.0070s\n-- add_index(:users, :email, {:unique=>true})\nrake aborted!\nStandardError: An error has occurred, all later migrations canceled:\n\nMysql2::Error: Specified key was too long; max key length is 767 bytes: CREATE UNIQUE INDEX `index_users_on_email`  ON `users` (`email`) ~/.rvm/gems/ruby-2.2.2/gems/mysql2-0.4.2/lib/mysql2/client.rb:107:in `_query'\n......\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上面那段訊息的重點在於："}]},{"type":"element","tag":"code","props":{"code":"Mysql2::Error: Specified key was too long; max key length is 767 bytes\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"Mysql2::Error: Specified key was too long; max key length is 767 bytes\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"也就說，作為 index 的欄位，他的長度（bytes）已經超過 MySQL 規定的 767 bytes 了，所以被 MySQL 拒絕繼續進行操作。"}]},{"type":"element","tag":"h2","props":{"id":"什麼時候會採用utf8mb4作為-mysql-的編碼"},"children":[{"type":"text","value":"什麼時候會採用 utf8mb4 作為 MySQL 的編碼？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在一般的情況下，其實 utf8 編碼就已經很夠用了，然而在 MySQL 6.0 前， 使用 utf8 一個字元最多只使用 3-Byte，所以他並不能表達所有 unicode 的字符。若是你的網站會使用的一些罕見字符或是有使用者是用罕見字元當做人名，就可能會不在 utf8 所支援的字符中。所以在 MySQL 5.5 時，新增了 utf8mb4 作為擴充，使最大佔用長度增為 4-byte。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"或許你會以為這種情況離生活很遠，但事實上在這個行動裝置隨處可見的情況下，這種情況反而更容易發生。為什麼？因為現在手機、平板等的輸入法，都多會附上表情符號諸如 [😎][😀][😁][😂][😃][😄][😅]"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"😆"}]},{"type":"text","value":"，這 8 個表符都各佔了 4-byte，也就是超過 utf8 的支援。我想讀者應該對這些符號都挺有印象的，所以這種採用 utf8mb4 作為 MySQL 的編碼的需求其實是離我們開發者越來越近。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://i0.wp.com/blog.fntsr.tw/wp-content/uploads/2016/02/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2016-02-20-%E4%B8%8A%E5%8D%883.12.53.png?ssl=1","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"","src":"https://i0.wp.com/blog.fntsr.tw/wp-content/uploads/2016/02/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7-2016-02-20-%E4%B8%8A%E5%8D%883.12.53.png?ssl=1"},"children":[]}]}]},{"type":"element","tag":"h2","props":{"id":"為什麼-rails-改用utf8mb4編碼就會超過長度呢"},"children":[{"type":"text","value":"為什麼 Rails 改用 utf8mb4 編碼就會超過長度呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那是因為 Rails ActiveRecord 的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":":string"}]},{"type":"text","value":" 資料欄位，等同於 MySQL 長度為 255 的 VARCHAR 欄位類型，所以使用 utf8 時，會使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"255 * 3 = 765"}]},{"type":"text","value":" (bytes)。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"當編碼改成 utf8mb4 後，每個字元固定長度為 4-byte，所以大小就會有 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"255 * 4 = 1020"}]},{"type":"text","value":" (bytes) ，而超過 MySQL 用來當作索引的鍵值長度的最大值。這也就是為什麼在資料庫 Migrate 會報錯的原因所在。"}]},{"type":"element","tag":"h2","props":{"id":"解決方案-1"},"children":[{"type":"text","value":"解決方案 (1)"}]},{"type":"element","tag":"h3","props":{"id":"方向"},"children":[{"type":"text","value":"方向"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"那我們該如何解決這個問題呢？"},{"type":"element","tag":"em","props":{},"children":[{"type":"text","value":"這裡提供的方案僅限於目前網站在開發，並沒有擁有需要保存資料的情況下才能實行"}]},{"type":"text","value":"。因為這個方案是透過修改 Rails 在資料表架構上，VARCHAR 類型欄位的預設長度。若是已經有資料的網站，可能會因為修改長度比現存的資料小，導致無法執行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"承襲上章所闡述的問題原因，為了改善這個問題，我們在這裡將 VARCHAR 的長度改成鍵值長度最大值以內。由算式 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"767 / 4 = 191 ... 3"}]},{"type":"text","value":" 可得知，在這個範圍內若以 4-byte 來儲存 1 個字符，我們共可以儲存 191 個字符，最大長度就只會到 764 bytes，符合 MySQL 標準，因而解決這個問題。所以解決方向就如前面所述，要將 Rails 的 VARCHAR 類型欄位的預設長度改成 191 個字符。"}]},{"type":"element","tag":"h3","props":{"id":"方法"},"children":[{"type":"text","value":"方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這個方法來自於 Github Rails/Rails 專案中的 "},{"type":"element","tag":"a","props":{"href":"https://github.com/rails/rails/issues/9855","rel":["nofollow"]},"children":[{"type":"text","value":"Issue #9885"}]},{"type":"text","value":" 中 @nanaya 的留言。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"我們在專案目錄下新增 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"./config/initializers/mysqlpls.rb"}]},{"type":"text","value":" 這個檔案，然後將下面的程式碼貼近檔案中儲存，就會將 VARCHAR 類型欄位的預設長度從 255 個字符改成 191 個字符，解決了這個問題。"}]},{"type":"element","tag":"code","props":{"code":"# config/initializers/mysqlpls.rb\nrequire 'active_record/connection_adapters/abstract_mysql_adapter'\n\nmodule ActiveRecord\n  module ConnectionAdapters\n    class AbstractMysqlAdapter\n      NATIVE_DATABASE_TYPES[:string] = { :name => \"varchar\", :limit => 191 }\n    end\n  end\nend\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"# config/initializers/mysqlpls.rb\nrequire 'active_record/connection_adapters/abstract_mysql_adapter'\n\nmodule ActiveRecord\n  module ConnectionAdapters\n    class AbstractMysqlAdapter\n      NATIVE_DATABASE_TYPES[:string] = { :name => \"varchar\", :limit => 191 }\n    end\n  end\nend\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這個程式碼主要是覆蓋掉原本 Rails 在這部分的設定，也就是說我要針對 ActiveRecord module 下的 ConnectionAdapters module 中的 AbstractMysqlAdapter Class 裡的 NATIVE_DATABASE_TYPES 雜湊常數中的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":":string"}]},{"type":"text","value":" 鍵值所代表的值做重新定義。講得這麼密麻麻，可能有點不懂，我們可以先看看原始針對這部份的定義，如下"}]},{"type":"element","tag":"code","props":{"code":"NATIVE_DATABASE_TYPES = {\n  primary_key: \"int auto_increment PRIMARY KEY\",\n  string:      { name: \"varchar\", limit: 255 },\n  text:        { name: \"text\" },\n  integer:     { name: \"int\", limit: 4 },\n  float:       { name: \"float\" },\n  decimal:     { name: \"decimal\" },\n  datetime:    { name: \"datetime\" },\n  time:        { name: \"time\" },\n  date:        { name: \"date\" },\n  binary:      { name: \"blob\" },\n  boolean:     { name: \"tinyint\", limit: 1 },\n  json:        { name: \"json\" },\n}\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"NATIVE_DATABASE_TYPES = {\n  primary_key: \"int auto_increment PRIMARY KEY\",\n  string:      { name: \"varchar\", limit: 255 },\n  text:        { name: \"text\" },\n  integer:     { name: \"int\", limit: 4 },\n  float:       { name: \"float\" },\n  decimal:     { name: \"decimal\" },\n  datetime:    { name: \"datetime\" },\n  time:        { name: \"time\" },\n  date:        { name: \"date\" },\n  binary:      { name: \"blob\" },\n  boolean:     { name: \"tinyint\", limit: 1 },\n  json:        { name: \"json\" },\n}\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這部份就是將 migration 中定義的資料類型轉成 MySQL 的欄位類型，而我們就是將原本 "},{"type":"element","tag":"string","props":{},"children":[]},{"type":"text","value":" 類型定義的長度做了修改並覆蓋。這樣解釋應該好懂很多。想要更深入了解的可以直接看 Rails 關於這部分的"},{"type":"element","tag":"a","props":{"href":"https://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract_mysql_adapter.rb#L37","rel":["nofollow"]},"children":[{"type":"text","value":"原始碼"}]},{"type":"text","value":"囉。"}]},{"type":"element","tag":"h3","props":{"id":"總結"},"children":[{"type":"text","value":"總結"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本解決方案是直接縮減 Rails 在 ActvieRecord 裡 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":":string"}]},{"type":"text","value":" 資料類型中的長度，以符合 MySQL 所支援的大小。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但如前面所述，若是你已經有資料，且你無法確保現有資料中 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":":string"}]},{"type":"text","value":" 資料類型的值都在 191 以下的話，就會比較麻煩。可能就要先將結構與資料分別 dump，改完結構後，再將資料中超過長度的值做縮減，最後再重新 import 到資料庫裡。這部分可參考 XDite 關於這部分所書寫的"},{"type":"element","tag":"a","props":{"href":"http://blog.xdite.net/posts/2013/12/19/mysql-with-utf8mb4","rel":["nofollow"]},"children":[{"type":"text","value":"部落格文章"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h2","props":{"id":"解決方案-2"},"children":[{"type":"text","value":"解決方案 (2)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這個方案我不打算如前一個方案般詳述，主要是因為我沒有實際去實驗，而只是將網路上看到的資料做個整理、筆記而已，實際運作上狀況如何，就不敢保證了，但至少紀錄了一個方向。"}]},{"type":"element","tag":"h3","props":{"id":"方向-1"},"children":[{"type":"text","value":"方向"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 MySQL 5.5.14 時，新增了一個名為 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"innodb_large_prefix"}]},{"type":"text","value":" 的功能，啟用後可將鍵值長度擴充到 3072 bytes。而這個功能相依於 MySQL 5.5 新增的一個叫做 Barracuda 的 innodb 的檔案格式（File Formate），這個檔案格式除了支援 innodb 原有的資料列格式（Row Formats），還包括了新的資料列格式：COMPRESSED 和 DYNAMIC。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以要解決這個問題，就是修改 MySQL 的選項，將檔案格式改成 Barracuda，並且啟用 innodb_large_prefix 這個選項去擴充鍵值長度。最後在 Rails 建立表格時，指定使用 DYNAMIC 的資料列格式即可。"}]},{"type":"element","tag":"h3","props":{"id":"方法-1"},"children":[{"type":"text","value":"方法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"在進行本方法前，請先將資料庫備份，或是使用虛擬機器或是容器開一個新的資料庫伺服器作為練習、試驗"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 MySQL 的設定檔 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"my.conf"}]},{"type":"text","value":" 加入下面內容："}]},{"type":"element","tag":"code","props":{"code":"[mysqld]\ninnodb_file_format = Barracuda\ninnodb_file_per_table = 1\ninnodb_large_prefix\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"[mysqld]\ninnodb_file_format = Barracuda\ninnodb_file_per_table = 1\ninnodb_large_prefix\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 Rails 部分有兩個選項，擇一即可，見仁見智。有興趣的可以參考在同一篇 Issue 裡，從"},{"type":"element","tag":"a","props":{"href":"https://github.com/rails/rails/issues/9855#issuecomment-57666389","rel":["nofollow"]},"children":[{"type":"text","value":"這篇回覆"}]},{"type":"text","value":"開始的討論，主要就是 @NaN1488 和 @yyyc514 兩人回覆的部分。"}]},{"type":"element","tag":"h4","props":{"id":"rails-1"},"children":[{"type":"text","value":"Rails (1)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在 migration 中的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"create_table"}]},{"type":"text","value":" 方法加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"option"}]},{"type":"text","value":" 參數："}]},{"type":"element","tag":"code","props":{"code":"create_table :table_name, options: 'ROW_FORMAT=DYNAMIC' do |t|\n  ...\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"create_table :table_name, options: 'ROW_FORMAT=DYNAMIC' do |t|\n  ...\n"}]}]}]},{"type":"element","tag":"h4","props":{"id":"rails-2"},"children":[{"type":"text","value":"Rails (2)"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若是覺得要在每個有建立資料表的 migration 一一加入上述選項的參數太麻煩的話，也可以直接加入一個 MonkeyPatch。這個 patch 會幫你在建立資料表時直接幫你加入該參數。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在專案目錄下新增 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"./config/initializers/ar_innodb_row_format.rb"}]},{"type":"text","value":" 這個檔案，並貼上程式碼："}]},{"type":"element","tag":"code","props":{"code":"ActiveSupport.on_load :active_record do\n  module ActiveRecord::ConnectionAdapters   \n    class AbstractMysqlAdapter \n      def create_table_with_innodb_row_format(table_name, options = {}) \n        table_options = options.reverse_merge(:options => 'ENGINE=InnoDB ROW_FORMAT=DYNAMIC')\n\n        create_table_without_innodb_row_format(table_name, table_options) do |td|\n         yield td if block_given? \n        end\n      end\n      alias_method_chain :create_table, :innodb_row_format \n    end\n  end\nend\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"ActiveSupport.on_load :active_record do\n  module ActiveRecord::ConnectionAdapters   \n    class AbstractMysqlAdapter \n      def create_table_with_innodb_row_format(table_name, options = {}) \n        table_options = options.reverse_merge(:options => 'ENGINE=InnoDB ROW_FORMAT=DYNAMIC')\n\n        create_table_without_innodb_row_format(table_name, table_options) do |td|\n         yield td if block_given? \n        end\n      end\n      alias_method_chain :create_table, :innodb_row_format \n    end\n  end\nend\n"}]}]}]},{"type":"element","tag":"h3","props":{"id":"總結-1"},"children":[{"type":"text","value":"總結"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"與前一方案是透過修改 Rails 對 string 欄位類型的預設長度達到目的，這個方案則是透過升級、修改 MySQL 的設定檔，擴大鍵值長度去修正這個錯誤。"}]},{"type":"element","tag":"h2","props":{"id":"結語"},"children":[{"type":"text","value":"結語"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"兩個方案方向不一樣，所以也沒有孰優孰劣，就看開發者當前的專案適合哪個方案了。若是沒有資料庫修改權限的，第一個方案我想就是一個挺貼切的做法，也讓專案在部署的難度降低。若是擁有資料庫伺服器管理權限，也可以使用第二個方案，直接一勞永逸囉。"}]},{"type":"element","tag":"h2","props":{"id":"附錄unicode-與-utf"},"children":[{"type":"text","value":"附錄：Unicode 與 UTF"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unicode 是一種文字、符號在電腦科學領域的業界標準，由非營利機構 The Unicode Consortium 負責。在 1991 年 10月發布第一個版本，隔年 6 月發布 1.0.1 擴增了中日韓統一表意文字最初的 20,902 個字，之後陸陸續需編修與擴增。最近的發布是在 2015 年 6 月時的 8.0 版本，總計有 120,737 個字符。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UTF 為 Unicode Transformation Format，中文為 Unicode轉換格式，即為 Unicode 的實作方式。"}]},{"type":"element","tag":"h3","props":{"id":"utf-8"},"children":[{"type":"text","value":"UTF-8"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"UTF-8 的全名為 8-bit Unicode Transformation Format，即以 1 個位元組（1-byte = 8-bit）為單位，用 1 到 4 個位元組表示一個字符編碼"},{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/293/#fn-293-2","rel":["nofollow"]},"children":[{"type":"text","value":"1"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"由於 UTF-8 的長度是可變動的，所以 ASCII 可以作為 UTF-8 的一個子集，所以現存的 ASCII 文字不需要轉換。"}]},{"type":"element","tag":"h4","props":{"id":"utf8mb3utf8mb4"},"children":[{"type":"text","value":"utf8mb3、utf8mb4"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"utf8mb3、utf8mb4 都是 MySQL 所支援的 Unicode 編碼實作，兩者的差別在於 utf8mb3 最大佔用長度為 3-byte，utf8mb4 則為 4-byte。所以其實兩者幾乎是一樣的，但是 utf8mb4 多了對擴充字符的支持，如本篇文章所提到的表情符號。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"utf8mb4 是 MySQL 5.5 所新增的，因為原本 MySQL 5.5 的 utf8 只有支持最大佔用長度為 3-byte，所以新增這個實作作為擴充。到了 MySQL 6.0，原本的 utf8 被更名為 utf8mb3，並加入新的 utf8 編碼實作，並預設支最大佔用長度為 4-byte。"},{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/293/#fn-293-3","rel":["nofollow"]},"children":[{"type":"text","value":"2"}]}]},{"type":"element","tag":"h2","props":{"id":"參考資料"},"children":[{"type":"text","value":"參考資料"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://github.com/rails/rails/issues/9855","rel":["nofollow"]},"children":[{"type":"text","value":"MySQL utf8mb4 breaks ActiveRecord schema setup"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://mathiasbynens.be/notes/mysql-utf8mb4","rel":["nofollow"]},"children":[{"type":"text","value":"How to support full Unicode in MySQL databases"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://encoding.spec.whatwg.org/#utf-8","rel":["nofollow"]},"children":[{"type":"text","value":"Encoding: Living Standard"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://www.utf8-chartable.de/unicode-utf8-table.pl?start=128512","rel":["nofollow"]},"children":[{"type":"text","value":"UTF-8 encoding table and Unicode characters"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://mothereff.in/byte-counter","rel":["nofollow"]},"children":[{"type":"text","value":"UTF-8 string length & byte counter"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://blog.kamipo.net/entry/2012/11/13/102024","rel":["nofollow"]},"children":[{"type":"text","value":"MySQL(InnoDB) で “Index column size too large. The maximum column size is 767 bytes.” いわれるときの対策"}]}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"原來的規範允許長達 6 位元組，但是在 2003 年 11 月 UTF-8 被 RFC 3629 重新規範，只能使用原來 Unicode 定義的區域，即 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"U+0000"}]},{"type":"text","value":" 到 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"U+10FFFF"}]},{"type":"text","value":" 。 "},{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/293/#fnref-293-2","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"↩","src":"https://s.w.org/images/core/emoji/14.0.0/svg/21a9.svg"},"children":[]}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"這部分可以參照 "},{"type":"element","tag":"a","props":{"href":"http://forums.mysql.com/read.php?3,199803,199803","rel":["nofollow"]},"children":[{"type":"text","value":"MySQL 6.0.4 Alpha 的 Release Note"}]},{"type":"text","value":"。 "},{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/293/#fnref-293-3","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"↩","src":"https://s.w.org/images/core/emoji/14.0.0/svg/21a9.svg"},"children":[]}]}]}]}]},"title_en":"MySQL utf8mb4 breaks ActiveRecord schema setup","slug":"my-sql-utf-8-mb-4-breaks-active-record-schema-setup","aliases":["解決 MySQL 使用 utf8mb4 編碼導致 Rails 資料庫遷移失敗的問題","MySQL utf8mb4 breaks ActiveRecord schema setup"],"created_at":"2016-02-21T23:30:29.000Z","published_at":null,"updated_at":null,"tags":["database","mysql","ruby-on-rails","web"],"moc":["Information Technology"],"_type":"markdown","_id":"garden:legacy-articles:2016-02-21-my-sql-utf-8-mb-4-breaks-active-record-schema-setup.md","_source":"garden","_file":"legacy-articles/2016-02-21-my-sql-utf-8-mb-4-breaks-active-record-schema-setup.md","_extension":"md"},{"_path":"/legacy-articles/2016-09-13-expose-jquery-to-global-variable-with-webpack","_dir":"legacy-articles","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"讓 jQuery 在 webpack 中成為全域變數","description":"","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/363/","rel":["nofollow"]},"children":[{"type":"text","value":"讓 jQuery 在 webpack 中成為全域變數 - 深藏若虛"}]}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這兩三年，可謂前端技術更迭不斷、框架不斷推陳出新的尖峰時期，本來就比較沒有再碰前端技術、以及專注在碩士求學生涯的我也算是落後許多。在拿到碩士學位後，又重新開始投入 Web 開發，不斷學習新知，尤其是在前端技術方面。最近開始使用 webpack 做為 module bundler，這篇主要就是紀錄初期使用 webpack 時遇到的一個撞牆點。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"儘管前端框架越來越多，angular.js、react.js 以及最近竄起的 vue.js 開始主導整個網頁前段的流程控制以及事件觸發，但是許多 CSS 框架仍是相依在 jQuery 上，且可能沒有對其他 JavaScript 框架有著完整的支援，所以在使用 JavaScript 框架之餘，仍需要使用 jQuery 作為驅動 CSS 框架的手段。最近開始嘗試使用 vue.js 與 webpack 的組合去做網站開發，在套用 semantic-ui 和 materialize 這兩門前端設計框架時，就遇到了找不到 jQuery 套件庫的錯誤，導致網站的 JavaScrit 程序被中斷，無法繼續執行下去。"}]},{"type":"element","tag":"h2","props":{"id":"誤區"},"children":[{"type":"text","value":"誤區"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"依照 webpack 去引入 JavaScript 的套件，以為只要在 js 檔案中加入下面兩行程式碼即可。但首先遇到的就是 JSLint 發出重複 import 的錯誤，直接否決掉這個做法。"}]},{"type":"element","tag":"code","props":{"code":"// Error: no-duplicate-imports  'jquery' import is duplicated\nimport $ from 'jquery'\nimport jQuery from 'query'\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Error: no-duplicate-imports  'jquery' import is duplicated\nimport $ from 'jquery'\nimport jQuery from 'query'\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"為了避開這個錯誤，改只有 import 一次，用變數賦值去改善這個問題。在引入 semantic-ui 或 materialize 時，仍然出現了 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ReferenceError: Can't find variable: jQuery"}]},{"type":"text","value":" 的錯誤。"}]},{"type":"element","tag":"code","props":{"code":"// Error: ReferenceError: Can't find variable: jQuery\nimport $ from 'jquery'\nvar jQuery = $\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Error: ReferenceError: Can't find variable: jQuery\nimport $ from 'jquery'\nvar jQuery = $\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"接著稍微 Google，有人提到要讓 jQuery 掛載 window 物件下成為全域變數，就可以解決問題了。所以嘗試以下面程式碼解決問題，但仍然得到 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ReferenceError: Can't find variable: jQuery"}]},{"type":"text","value":" 的錯誤。"}]},{"type":"element","tag":"code","props":{"code":"// Error: ReferenceError: Can't find variable: jQuery\nimport jquery from 'jquery'\n\nwindow.$ = jquery\nwindow.jQuery = jquery\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"// Error: ReferenceError: Can't find variable: jQuery\nimport jquery from 'jquery'\n\nwindow.$ = jquery\nwindow.jQuery = jquery\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以上解法都失敗。目前對於 webpack 還不甚熟悉，只有在同一個檔案內的程式碼可以使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"$"}]},{"type":"text","value":"、"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"jQuery"}]},{"type":"text","value":" 呼叫 jQuery，但若是 import 的 JavaScript 套件需要 jQuery 時就會找不到，在網頁開啟開發者工具區呼叫這兩個變數時也會找不到。推估是因為 webpack 對於每個檔案的變數宣告的作用範圍 (scope) 都侷限在檔案裡，不會真的成為全域變數，所以就算把 jQuery 掛在 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"window"}]},{"type":"text","value":" 物件內，仍無法解決問題。這個假設等未來對前端更熟悉後，再來嘗試驗證。"}]},{"type":"element","tag":"h2","props":{"id":"解法"},"children":[{"type":"text","value":"解法"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"既然無法從單個檔案解決問題，就只好換個方向，嘗試使用設定檔解決問題。繼續嘗試 Google 尋找資料，得到大致有兩種解法，且都是可以運作的。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不管是何種解法，首先就是要透過 npm 安裝 jQuery："}]},{"type":"element","tag":"code","props":{"code":"npm install --save jquery\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"npm install --save jquery\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第一種是使用 webpack plugin 的方式，透過 Provide Plugin "},{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/363/#fn-363-1","rel":["nofollow"]},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" 讓 jQuery 成為全域變數。編輯 webpack 的設定檔，在 module.exports.plugins 中加入 Webpack ProvidePlugins，並把 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"$"}]},{"type":"text","value":"、"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"jQuery"}]},{"type":"text","value":" 這兩個全域變數指向 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"jquery"}]},{"type":"text","value":" 套件庫。"}]},{"type":"element","tag":"code","props":{"code":"plugins: [\n  // other plugins\n  // ...\n  new webpack.ProvidePlugin({\n     $: \"jquery\",\n     jQuery: \"jquery\"\n  })\n]\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"plugins: [\n  // other plugins\n  // ...\n  new webpack.ProvidePlugin({\n     $: \"jquery\",\n     jQuery: \"jquery\"\n  })\n]\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"第二種解法則是使用 expose-loader。首先先透過 npm 安裝 expose-loader："}]},{"type":"element","tag":"code","props":{"code":"npm install expose-loader --save\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"npm install expose-loader --save\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"然後編輯 webpack 的設定檔，在 module.exports.loaders 中加入下面的程式碼，把 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"jquery"}]},{"type":"text","value":" 套件庫揭露 (expose) 成 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"$"}]},{"type":"text","value":"、"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"jQuery"}]},{"type":"text","value":" 這兩個全域變數。"}]},{"type":"element","tag":"code","props":{"code":"loaders: [\n  // other loaders\n  // ...\n  {\n    test: require.resolve('jquery'),\n    loader: 'expose?jQuery!expose?$'\n  }\n]\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"loaders: [\n  // other loaders\n  // ...\n  {\n    test: require.resolve('jquery'),\n    loader: 'expose?jQuery!expose?$'\n  }\n]\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"設定檔完成後，重新啟動伺服器。此時網頁仍會顯示 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ReferenceError: Can't find variable: jQuery"}]},{"type":"text","value":" 的錯誤。這時打開網頁的腳本，加入下面的程式碼即可解決這個問題。"}]},{"type":"element","tag":"code","props":{"code":"import 'jquery`\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"import 'jquery`\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"補充：後來在參考資料第二項的文章裡，發現還有許多其他解法，有興趣的可以前往該頁面閱讀。"}]},{"type":"element","tag":"h2","props":{"id":"參考資料"},"children":[{"type":"text","value":"參考資料"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://stackoverflow.com/questions/29080148/expose-jquery-to-real-window-object-with-webpack","rel":["nofollow"]},"children":[{"type":"text","value":"Expose jQuery to real Window object with Webpack"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://stackoverflow.com/questions/28969861/managing-jquery-plugin-dependency-in-webpack","rel":["nofollow"]},"children":[{"type":"text","value":"Managing Jquery plugin dependency in webpack"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"http://react-china.org/t/webpack-jquery-bootstrap/1669","rel":["nofollow"]},"children":[{"type":"text","value":"React China – 求大牛帮忙，用webpack 打包jquery、bootstrap时出错。"}]}]},{"type":"element","tag":"li","props":{},"children":[{"type":"element","tag":"a","props":{"href":"https://rhadow.github.io/2015/05/30/webpack-loaders-and-plugins/","rel":["nofollow"]},"children":[{"type":"text","value":"Rhadow’s Tech Note – 深入了解 Webpack Plugins"}]}]}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"「Provide Plugin 的主要功能是當在程式中遇到特定字元且沒被定義時會自動載入特定模組。」via Ref-4 "},{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/363/#fnref-363-1","rel":["nofollow"]},"children":[{"type":"element","tag":"img","props":{"alt":"↩","src":"https://s.w.org/images/core/emoji/14.0.0/svg/21a9.svg"},"children":[]}]}]}]}]},"title_en":"Expose jQuery to global variable with Webpack","slug":"expose-jquery-to-global-variable-with-webpack","aliases":["讓 jQuery 在 webpack 中成為全域變數","Expose jQuery to global variable with Webpack"],"created_at":"2016-09-13T14:19:24.000Z","published_at":null,"updated_at":null,"tags":[],"moc":["Information Technology"],"_type":"markdown","_id":"garden:legacy-articles:2016-09-13 -expose-jquery-to-global-variable-with-webpack.md","_source":"garden","_file":"legacy-articles/2016-09-13 -expose-jquery-to-global-variable-with-webpack.md","_extension":"md"}]