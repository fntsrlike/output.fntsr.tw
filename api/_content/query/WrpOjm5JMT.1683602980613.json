[{"_path":"/legacy-articles/2017-07-07-introduce-the-programmer-for-students-of-junior-high","_dir":"legacy-articles","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"對國中生介紹程式設計師這個職業","description":"","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這篇文章是前陣子受到擔任中學教師的朋友邀稿，寫給國中生看的職業專欄。嘗試在有限的篇幅以及制式模板下，盡量以國中生看得懂的描述去介紹這個行業，雖然難免還是會混進許多專有名詞，但朋友說近來因為資訊科技普及，許多學生多少會把這個行業想得太簡單，留點專有名詞，至少讓這些學生知道這行沒有想像中的簡單，好吧，希望不會讓這些小孩一看到這篇文章就直接拿去墊便當了。 XDrz"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"既然都寫完了，也就順便發佈到部落格，希望能給對資訊圈有興趣的朋友，簡單了解程式設計圈的產品、專案大概是怎麼劃分、又大概分哪些職責。因為我也沒有真正踏進業界，所以或許有些見解偏離實際狀況，在這邊還請讀者多多見諒。願意幫忙糾正以及想知道其他人給予建議的朋友，可以訪問"},{"type":"element","tag":"a","props":{"href":"https://docs.google.com/document/d/1KQshU9yCGeGR_pv4RIndJ_VD00RJjvoJHDEFFb2fJFM/edit?usp=sharing","rel":["nofollow"]},"children":[{"type":"text","value":"這篇Google 文件"}]},{"type":"text","value":"。最後感謝 "},{"type":"element","tag":"a","props":{"href":"https://github.com/freetsubasa","rel":["nofollow"]},"children":[{"type":"text","value":"freetsubasa"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"https://github.com/iblis17","rel":["nofollow"]},"children":[{"type":"text","value":"iblis17"}]},{"type":"text","value":"、michaelnity、"},{"type":"element","tag":"a","props":{"href":"https://github.com/tjjh89017","rel":["nofollow"]},"children":[{"type":"text","value":"tjjh89017"}]},{"type":"text","value":"、"},{"type":"element","tag":"a","props":{"href":"https://github.com/xatier","rel":["nofollow"]},"children":[{"type":"text","value":"xatier"}]},{"type":"text","value":" 在這篇文章編寫時，提供建議與修正。"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本篇文章授權台南慈中國中部輔導室使用，並得以不經同意直接修改、發佈在學校的生涯發展專欄中。"}]}]},{"type":"element","tag":"h2","props":{"id":"前言"},"children":[{"type":"text","value":"前言"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"隨著智慧型手機普及，資訊科技從庶民化再次突破，跨越了年齡，很直接的走進老少青壯的世界裡，各種琳瑯滿目的手機應用程式融入了我們的生活，各類遊戲也成為學生裡聊不完的話題。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這些程式背後都是有一群程式設計師進行編寫的，這是個很常聽到，但想去了解才發現被雲霧所包圍的職業。太多形象來自於電影中快速敲打鍵盤，瞬間入侵電腦的駭客，或是動漫畫裡厚重眼鏡盯著電腦的人物。到底程式設計師是一個怎樣的職業？喜歡玩電腦是否就代表適合成為一個程式設計師？我想這也是現代青少年心中免不了的疑惑。"}]},{"type":"element","tag":"h2","props":{"id":"簡介定義"},"children":[{"type":"text","value":"簡介（定義）"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"程式設計師（又稱程式工程師、軟體工程師、開發人員等），其職責主要在於編寫軟體，軟體的定義很廣泛，舉凡在資訊領域，和硬體電路設計、製造無關的，都能算是軟體的範疇。一般人比較常聽到的軟體程式通常是高階應用的部分，像是指直接運行在作業系統（Windows, macOS, Linux, Android, iOS）的應用程式，像是 Office Word"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n、遊戲軟體、手機 App 等；或是透過瀏覽器（（IE、Chrome、Safari）瀏覽的網站；另外作業系統本身以及與其相關的工具程式，也是軟體一部分，其中當然也包括讓硬體與作業系統溝通的驅動程式等等。除了軟體的編寫外，伺服器維運、資訊硬體設備管理通常也會是程式設計師的工作範圍。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"雖然程式設計師在台灣薪水，相較於其他職業高，且有可能在家工作或是有彈性的工作空間。但是，工時也是比其他職業還要長，甚至需要隨呼隨到（On Call），如果自已負責的程式、軟體發生重大錯誤，加班到天亮或是半夜被叫醒，也都是很正常的事情。雖然在電影中很常看到駭客或是程式設計師以神乎其技的方式達成任務，但那通常都是需要數十年的累積，且以在旁人看起來孤獨、枯燥的方式去自我學習才能趨近這種功力。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在台灣的就職市場，常因為程式設計很難單純透過視覺展示其成果與背後努力的多寡，導致工作成果被認為廉價或是簡單。與和其他職業溝通也很有著難以跨越的鴻溝，很難和外人分享自己的成果與喜悅。加上時間多用在進修技術上，所以交友也多局限於資訊圈中，"}]},{"type":"element","tag":"h2","props":{"id":"特質"},"children":[{"type":"text","value":"特質"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"充滿好奇與求知慾"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"樂於分享知識、參與社群（Community）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"真心熱愛寫程式"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"專業主義（Profesionalism）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"謙虛，永遠知道自己所學的還只是冰山一角"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"不被既有框架束縛"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"追求品質"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"駭客文化（Hacker Culture）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"自造文化（Maker Culture）"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"開放文化（Open Culture）"}]}]},{"type":"element","tag":"h2","props":{"id":"工作內容"},"children":[{"type":"text","value":"工作內容"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因為軟體的範疇很廣，所以工作內容也很多元，但觀念上都是以程式設計理論為基礎，只是使用的程式語言（programming language）與框架（framework）不同而已。若要簡單區分，通常會以平台或領域的不同作為劃分："}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"桌面程式：平時電腦、筆電使用的軟體就是桌面軟體，例如 Microsoft Office。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"手機程式：在手機上的各個 App，就是手機程式。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"網頁程式：透過瀏覽器上網看到的網站，都是網頁程式。"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"系統程式：作業系統、驅動程式、工具鏈程式。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外每項軟體專案的開發，可能又會細分為不同的職責："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"一、規劃"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n主要負責根據軟體需求來去定主要使用的技術、設計系統的主體框架，並負責指導其他程式設計師進行程式碼的開發工作。負責這項職責的通常稱為系統架構師（System Architect）和系統分析師（System Analyst）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"二、開發"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n程式開發的主力，通常所稱的程式設計師就是泛指負責這項職責的人員，通常稱為開發者（Developer）。開發者根據架構師訂定的系統架構與專案經理（PM）提出的時程規劃和整理好的客戶需求，去開發程式。除了熟悉規格所要求使用的工具——程式語言與框架外，對資訊科學相關的基礎理論也要有所了解，尤其是計算機概論、計算機結構、資料結構、演算法、網路概論等，如此才能夠針對需求做程式設計、並編寫出有效率且少有錯誤的程式。另外設計模式、物件導向、軟體工程等知識，則會增進開發者在程式編寫上的品質與可維護性。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"三、測試、品質控管"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n一套軟體從開發完成到交予使用者前，都需要經過測試，確保程式邏輯正常、軟體的功能有如預期，且不容易發生意料之外的錯誤，進而造成程式停止運作。這邊會特別指有能力根據軟體功能需求去設計一套測試流程的人員，而非遵從流程重複機械性動作去測試一次又一次的勞力。另外測試也分為數個階段，從最單純的驗證程式模組單一功能性的單元測試、到程式組件整合後的整合測試，再來是確認軟體是否符合需求和預期效能的系統測試，以及為了檢驗軟體原有功能在修改後是否保持一致的回歸測試等。負責這項職責的人員通常稱為品質確保（Quality Control，簡稱QC），但近年來開發者通常也要自備簡單的測試能力，尤其是單元測試的設計與編寫自動化測試程式的職責。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"四、維運"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n現代的軟體、程式幾乎很難離開網路，舉凡網路服務（線上購物、部落格、Facebook）、雲端軟體（像是 Google Docs、Dropbox）、線上遊戲、可以課金或是和其他人簡單互動的手遊皆是如此，而除了使用者所使用的軟體外，這背後都需要有程式在伺服器接收資訊、運算，並回傳資訊給使用者的軟體。程式除了經由上述四項職責共同生產，建置能讓程式正常運作的環境，則是在正式營運前必須通過的最後一道關卡。其中要考慮的事情很多，包括該程式所相依的其他程式是否已經安裝、版本是否與開發使用的相同、現有的運算資源是否能夠撐起多少人同時訪問（簡單的比喻就是，這款線上遊戲能夠讓多少人同時上線）、能不能簡單快速的將程式部署，且行為模式ㄧ樣等等，這些與維護和營運相關的職責就簡稱維運（Operations，簡稱Ops）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"五、資訊安全"}]},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n程式在編寫時，很容易因為開發者的疏忽，或是對該技術的不了解，進而產生漏洞（vulnerabilities）。這些漏洞或許不會造成軟體使用上的困擾或是錯誤，程式照樣能照使用者所預期的進行，但這些漏洞卻會被有心人士利用，成為入侵或破壞的管道。最近很猖狂的勒索病毒 Wanna Cry 就是利用 Windows 作業系統的漏洞進行入侵、感染、並破壞，最後勒索要求還原的贖金。利用這些漏造成危害的人，稱為黑帽駭客（Black Hat）、破壞者（Cracker），相對的，ㄧ樣會去探索軟體是否有漏洞，但是會通報作者或是協助修補的人，則稱為白帽駭客（White Hat）、駭客（Hacker），也就是主要負責資訊安全職責的人員。這部分是另一個專業，也是台灣資訊社群近來正積極投入的領域之一。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"不管程式設計師事負責哪項職責，主要都是從開發者為基礎去延伸的，且由於資訊科技快速的，除了理論上的進步，技術的實作更是推陳出新，各種框架後浪推前浪，如果程式設計師停下學習的腳步，很容易就會被潮流給淘汰。除了原有理論的必須不斷溫故知新外，對技術的掌握更是不能懈怠，也不能故步自封的單純守著自己得職責。像近年由於軟體工程的進步，興起一個名詞稱為 DevOps，主要是將開發、測試、維運串起來，透過自動化「軟體交付」和「架構變更」的流程，來使得構建、測試、發布軟體能夠更加地快捷、頻繁和可靠。也顯示出近年程式設計師不再只單純負責一項職責，對其他職責也必須有所了涉獵、甚至參與。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"上述只是針對職責去闡述工作內容，但要更了解程式設計師，則必須了解其日常生活。由於是靠資訊吃飯的，程式設計師在工作上也幾乎是整天看著電腦，長時間坐在電腦前思考、編寫程式只能算是家常便飯，更甚至會為了某項問題加班甚至通宵。若不是有「想把問題解決不然不罷休」的特質，是很難在這行堅持著，事實上在外行看來覺得枯燥的行為下，對程式設計師而言卻像解謎一樣有趣，儘管樂趣難向外行所言，但是一但把問題解決時的成就感就像是觸碰到世界真理一樣，令人雀躍且滿足。每位程式設計師的心裡頭，都有一個駭客的靈魂，熱衷解決問題，突破限制，並享受電腦按照自己指令按部就班進行的成就感。"}]},{"type":"element","tag":"h2","props":{"id":"待遇"},"children":[{"type":"text","value":"待遇"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"程式設計師的初步待遇依照地區與資歷有所不同，初級程式設計師（Junior）約為28K到50K，資深程式設計師（Senior）約33K到80K，中南部大概都在待遇比較低的區間，北部則是在待遇比較高的區間，尤其是雙北市和中南部的待遇差異甚大。也因為北部職缺多且待遇較好，多數程式設計師都會前往北部尋找工作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"傳統產業公司的資訊部分對待程式設計師與其他職業差不多。但若是在新創公司或是純軟公司裡，程式設計師通常會得到一個比較好的開發環境，像是公司配給的電腦與週邊設備、提供書籍預算添購所需書籍，有些甚至會提供零食、飲料或是每週一次的下午茶時間，為的就是讓急需專注力的程式設計師能夠心無旁騖地投入到工作中。"}]},{"type":"element","tag":"h2","props":{"id":"延伸閱讀"},"children":[{"type":"text","value":"延伸閱讀"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這邊提供一些書單，讓有興趣的朋友可以透過這些讀來了解這個行業與其文化。"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"賀元著（1995），《資訊遊俠列傳》，臺北市：資訊人文化"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"黃志賢等著（1995），《我的電腦探索》，臺北市：資訊人文化"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Daniel Hillis著，林遠志，陳振男譯，《電腦如何思考（The Pattern on The Stone）》，臺北市：天下文化"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Frederick P. Brooks, Jr.著，錢一一譯（2004），《人月神話：軟體專案管理之道》，臺北市：經濟經潮社"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Paul Graham著，莊友欣、莊惠淳譯（2006），《駭客與畫家》，臺北市：碁峰資訊"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Dave Hoover, Adewale Oshineye著，莊弘祥譯（2011），《學徒模式：優秀軟體開發者的養成之路》，臺北市：碁峰資訊"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Steven Levy著，Jedi, Pluto譯（2012），《黑客列傳：電腦革命俠客誌（25週年紀念版）》，臺北市：碁峰資訊"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"Robert C. Martin著，陳錦輝譯（2013），《無瑕的程式碼 番外篇：專業程式設計師的生存之道》，臺北市：博碩文化"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"夏海公司著，志麻、蔡長弦譯（2011），《奮鬥吧！系統工程師》，臺北市：台灣角川"}]}]}]},"title_en":"Introduce The Programmer for Students of Junior High","slug":"introduce-the-programmer-for-students-of-junior-high","aliases":["對國中生介紹程式設計師這個職業","Introduce The Programmer for Students of Junior High"],"created_at":"2017-07-07T15:39:43.000Z","published_at":null,"updated_at":null,"tags":[],"_type":"markdown","_id":"garden:legacy-articles:2017-07-07-introduce-the-programmer-for-students-of-junior-high.md","_source":"garden","_file":"legacy-articles/2017-07-07-introduce-the-programmer-for-students-of-junior-high.md","_extension":"md"},{"_path":"/legacy-articles/2017-09-17-transaction-design-of-postgre-sql-and-my-sql","_dir":"legacy-articles","_draft":false,"_partial":false,"_locale":"en","_empty":false,"title":"PostgreSQL 與 MySQL 關於 transaction 的設計理念","description":"","excerpt":{"type":"root","children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"近日因為想要跳槽到 PostgreSQL，所以開始閱讀官方的參考文件。在讀到 "},{"type":"element","tag":"a","props":{"href":"https://www.postgresql.org/docs/9.6/static/tutorial-transactions.html","rel":["nofollow"]},"children":[{"type":"text","value":"3.4 Transactions"}]},{"type":"text","value":" 時，其中有一段不太能理解："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PostgreSQL actually treats every SQL statement as being executed within a transaction. If you do not issue a BEGIN command, then each individual statement has an implicit BEGIN and (if successful) COMMIT wrapped around it. A group of statements surrounded by BEGIN and COMMIT is sometimes called a transaction block."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"因為以往對 transaction"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^1"}]},{"type":"text","value":"的了解不深，一直以為只會用在「我有數個 SQL 敘述，希望能夠其中一個失敗時，取消其他 SQL 敘述的執行」的情況，所以不太能理解「每個 SQL 敘述預設帶有一個 transaction」的設計，非常疑惑為什麼會需要將單個 SQL 敘述也用 transaction 包起來。所以就去請教了對 PostgreSQL 有經驗的 "},{"type":"element","tag":"a","props":{"href":"https://github.com/david50407","rel":["nofollow"]},"children":[{"type":"text","value":"@david50407"}]},{"type":"text","value":"。本篇文章大概就是在講述敝人向其請教後的理解。"}]},{"type":"element","tag":"h2","props":{"id":"基本觀念"},"children":[{"type":"text","value":"基本觀念"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PostgreSQL 參考手冊在 "},{"type":"element","tag":"a","props":{"href":"https://www.postgresql.org/docs/9.6/static/tutorial-transactions.html","rel":["nofollow"]},"children":[{"type":"text","value":"3.4 Transactions"}]},{"type":"text","value":" 的第一段，就以這樣的文字來敘述："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The essential point of a transaction is that it bundles multiple steps into a single, all-or-nothing operation. The intermediate states between the steps are not visible to other concurrent transactions, and if some failure occurs that prevents the transaction from completing, then none of the steps affect the database at all."}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"該文字的意思大概就是，transaction 可以把 PostgeSQL 裡面多個敘述併成一個，並且遵從「全或無」（all-or-nothing）"},{"type":"element","tag":"sup","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#user-content-fn-2","ariaDescribedBy":"footnote-label","dataFootnoteRef":true,"id":"user-content-fnref-2"},"children":[{"type":"text","value":"1"}]}]},{"type":"text","value":" 的操作；也就是若在併成一個操作裡的諸多敘述，若有其中一個敘述出錯，其他成功的敘述也會被撤銷，就等同全部都沒有執行。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這個功能比較常用的地方就在於金融業，常見的例子就是要避免 A 轉帳給 B 時，不能發生「扣了 A 的錢，但 B 那邊卻沒有增加」或是「對 A 扣錢失敗，但是 B 那邊的錢卻增加了」的情況，一定是要「扣了 A 的錢，也要加 B 的錢」，不然就是都不要發生。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在沒有特別處理的情況下，SQL 敘述大致如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-1"}]},{"type":"text","value":"：在沒有使用 transaction 的銀行交易情境示例"}]},{"type":"element","tag":"code","props":{"code":"UPDATE accounts SET deposit = deposit - 30000.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 30000.00 WHERE name = 'B';\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"UPDATE accounts SET deposit = deposit - 30000.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 30000.00 WHERE name = 'B';\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"但若因為某種原因導致第一個敘述失敗，第二個敘述卻成功了，那麼銀行就會損失三萬元。若第一個敘述成功了，第二個敘述失敗，那顧客就會平白無故損失三萬元，導致銀行信譽掃地。所以在處理這類需要「全或無」的操作時，就必須將這些敘述宣告成一個 transaction block"},{"type":"element","tag":"a","props":{"href":"http://blog.fntsr.tw/articles/904/#fn-904-transaction","rel":["nofollow"]},"children":[{"type":"text","value":"1"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"transaction block 的宣告方式，就是使用 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 兩個敘述，將多個需要綁定的 SQL 敘述給包起來，以上面的案例來改進，大致如下："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-2"}]},{"type":"text","value":"：使用 transaction 的銀行交易情境示例"}]},{"type":"element","tag":"code","props":{"code":"BEGIN;\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"BEGIN;\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若 transaction block 圍起來的敘述，只要有其中一個不成立，那麼 transaction block 裡的敘述就都不會被執行"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^3"}]},{"type":"text","value":"。"}]},{"type":"element","tag":"h2","props":{"id":"postgresql-關於-transaction-的設計理念"},"children":[{"type":"text","value":"PostgreSQL 關於 transaction 的設計理念"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"回到原本的疑問，在解惑之前先闡述一個 PostgreSQL 的基本概念："}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"PostgreSQL 一次只會執行一個原子級操作（atomic operation，意味這該項操作不可分割），PostgreSQL 只會在完成一次原子級操作才會將結果從記憶體寫入檔案，若是中間有任何衝突，就會重新從檔案讀取資料回記憶體覆蓋失敗的部分、進行還原。"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"講到這邊，大概就能有點感覺。是的，transaction 就是 PostgreSQL 的原子級操作。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在沒有自行加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 語法的情況下，PostgreSQL 是不會把結果從記憶體存回硬碟，但是為了方便操作，PostgreSQL 預設會把沒有在 transaction block 中的 SQL 敘述外自動加入"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":"和 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":"，也就是將該則敘述獨立視為一個 transaction block。如此才不用在編寫 SQL 敘述時，還有手動加上一對冗贅的 transaction 語法。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"以"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-1"}]},{"type":"text","value":" 為例，雖然我們沒有幫他加上 transaction 語法，但是事實上它在執行時，是已經被 PostgreSQL 加入語法了，其真實的樣貌如下（"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 2-1"}]},{"type":"text","value":"）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 2-1"}]},{"type":"text","value":"：PostgreSQL transaction 預設行為示例"}]},{"type":"element","tag":"code","props":{"code":"-- 本段程式碼的 BEGIN; 和 COMMIT; 都是 PostgreSQL 自動加的\nBEGIN;  \nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nCOMMIT;\nBEGIN;\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-- 本段程式碼的 BEGIN; 和 COMMIT; 都是 PostgreSQL 自動加的\nBEGIN;  \nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nCOMMIT;\nBEGIN;\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"所以每項敘述都會是一個原子級操作，都被視為一個 transaction block，在成功完成後，才會寫入硬碟。若失敗則會跳下一個敘述繼續執行（這邊是假設匯入 SQL檔的情境，其他情境要視失敗時對例外地處理決策決定是中止操作還是繼續執行）。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"從上面透過設計理念的理解，原本的問題也就豁然開朗。了解其背後理念和原因後，也可以繼續思考以下問題，讓自己對這份知識更加熟稔："}]},{"type":"element","tag":"h5","props":{"id":"問題一"},"children":[{"type":"text","value":"問題一"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"匯入一個 SQL 文件 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dump.sql"}]},{"type":"text","value":" 到 PostgreSQL 時，假設 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"dump.sql"}]},{"type":"text","value":" 裡沒有任何 transaction 語法，並有 N 行敘述，而第 M 行敘述是會發生衝突的，那資料庫最後會有幾筆異動？"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n(A) N 筆（成功執行所有敘述）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n(B) N – 1 筆（成功執行除了第 M 行以外的敘述）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n(C) M – 1 筆（只成功執行第 M 行之前的敘述，第 M 行及其之後的敘述都被駁回）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"text","value":"\n(D) 0 筆（全部敘述遭到駁回）"}]}]},{"type":"element","tag":"h5","props":{"id":"問題二"},"children":[{"type":"text","value":"問題二"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"承問題一，若答案不是 (D) 選項，那為什麼在一起匯入的情況下，不是所有敘述都被駁回，而是部分被套用？"}]}]},{"type":"element","tag":"h5","props":{"id":"問題三"},"children":[{"type":"text","value":"問題三"}]},{"type":"element","tag":"blockquote","props":{},"children":[{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"承問題二，那該怎麼做，才能讓匯入 SQL 文件到 PostgreSQL 時，是一有失敗就全部駁回，而不是部分套用呢？"}]}]},{"type":"element","tag":"h2","props":{"id":"與-mysql-比較"},"children":[{"type":"text","value":"與 MySQL 比較"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"在略曉 PostgreSQL 關於 transaction 的設計後，在這節轉向探討 MySQL 關於 transaction 的設計。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MySQL 也是擁有 transaction 功能的，也定義了 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^4"}]},{"type":"text","value":"、"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT"}]},{"type":"text","value":" 語法。它也會預設對沒有在 transaction block 中的 SQL 敘述，進行預設的行為，那到底是哪邊跟 PostgreSQL 不同呢？"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"MySQL 的設計理念是在於，遇到 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 語法時，才會將資料從記憶體寫入硬碟，並且預設會對所有 SQL 敘述後自動在其後加上 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":"，在 MySQL 稱這項預設行為為自動提交（auto commit）。以"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-1"}]},{"type":"text","value":" 為例，在 MySQL 中其真實的樣貌如下（"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-1"}]},{"type":"text","value":"）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-1"}]},{"type":"text","value":"：MySQL auto commit 行為的示例"}]},{"type":"element","tag":"code","props":{"code":"-- 本段程式碼的 COMMIT; 都是 MySQL 自動加的\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nCOMMIT;\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"-- 本段程式碼的 COMMIT; 都是 MySQL 自動加的\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nCOMMIT;\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"和"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 2-1"}]},{"type":"text","value":" 進行比較後，會發現 MySQL 在預設行為上，只會在敘述後加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 而不會在之前加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":"，這邊就顯示出兩者在設計概念上的不同。PostgreSQL 是以一個 transaction block 為一個單位作為 transaction 的操作；而 MySQL 則是以當下的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 到上一個 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 之間的敘述作為 transaction 的操作（準確來說，是指目前還沒被提交過的敘述）。而 MySQL 的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 就類似一個局部停用自動提交的語法，並作用到一個 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 或 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ROLLBACK;"}]},{"type":"text","value":" 語法為止，如"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-2"}]},{"type":"text","value":" 所示。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-2"}]},{"type":"text","value":"：MySQL BEGIN & COMMIT 示例"}]},{"type":"element","tag":"code","props":{"code":"BEGIN;\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"BEGIN;\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"若是要在當前連線全域關閉這個自動動提交（auto commit）"},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^5"}]},{"type":"text","value":"，可以透過 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"SET autocommit=0;"}]},{"type":"text","value":" 敘述，當 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"autocommit"}]},{"type":"text","value":" 設置為 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"0"}]},{"type":"text","value":" 時，就會停用自動提交。若將這功能停用時，就必須自己加入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 以將之前執行成功且尚未提交過的敘述存入硬碟。與 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 不同，就算遇到 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":"，自動提交仍會保持停用，直到將 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"autocommit"}]},{"type":"text","value":" 設置為 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":" 重啟這功能為止。同樣以"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 1-1"}]},{"type":"text","value":" 作為案例，大致如下（"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-3"}]},{"type":"text","value":"）："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-3"}]},{"type":"text","value":"：MySQL autocommit 設置示例"}]},{"type":"element","tag":"code","props":{"code":"SET autocommit=0;\n\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT; -- COMMIT 並不會讓 autocommit 重新啟用\n\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'C';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'D';\nROLLBACK; -- ROLLBACK 也不會讓 autocommit 重新啟用\n\nSET autocommit=1; -- 只有將 autocommit 設置為 1 時，才會重啟自動提交的功能。\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"SET autocommit=0;\n\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'A';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'B';\nCOMMIT; -- COMMIT 並不會讓 autocommit 重新啟用\n\nUPDATE accounts SET deposit = deposit - 100.00 WHERE name = 'C';\nUPDATE accounts SET deposit = deposit + 100.00 WHERE name = 'D';\nROLLBACK; -- ROLLBACK 也不會讓 autocommit 重新啟用\n\nSET autocommit=1; -- 只有將 autocommit 設置為 1 時，才會重啟自動提交的功能。\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"除了自動提交外，在 MySQL 參考手冊的 "},{"type":"element","tag":"a","props":{"href":"https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html","rel":["nofollow"]},"children":[{"type":"text","value":"13.3.3 Statements That Cause an Implicit Commit"}]},{"type":"text","value":" 有提到，當遇到修改資料表的敘述、資料定義語言（DDL）、或是 transactions 控制流程 "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^6"}]},{"type":"text","value":"和資料表鎖定相關的敘述時，在執行該敘述前，都會自動執行 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":"，也就是所謂的隱性提交（implicitly commit）"},{"type":"element","tag":"sup","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#user-content-fn-7","ariaDescribedBy":"footnote-label","dataFootnoteRef":true,"id":"user-content-fnref-7"},"children":[{"type":"text","value":"2"}]}]},{"type":"text","value":"。這部分可以參見"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-4"}]},{"type":"text","value":" 的示例加深理解。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-4"}]},{"type":"text","value":"：MySQL 隱性提交示例"}]},{"type":"element","tag":"code","props":{"code":"SET autocommit=0; -- 先停用自動提交\n\nINSERT INTO log (content) VALUES ('A');\n\nBEGIN; -- 執行此行敘述前，會進行隱性提交，導致前面的 SQL 敘述被存入硬碟。\nINSERT INTO log (content) VALUES ('B');\nCOMMIT;\n\nINSERT INTO log (content) VALUES ('C');\n\nSET autocommit=1; -- 執行此行敘述前，會進行隱性提交，導致前面的 SQL 敘述被存入硬碟。\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"SET autocommit=0; -- 先停用自動提交\n\nINSERT INTO log (content) VALUES ('A');\n\nBEGIN; -- 執行此行敘述前，會進行隱性提交，導致前面的 SQL 敘述被存入硬碟。\nINSERT INTO log (content) VALUES ('B');\nCOMMIT;\n\nINSERT INTO log (content) VALUES ('C');\n\nSET autocommit=1; -- 執行此行敘述前，會進行隱性提交，導致前面的 SQL 敘述被存入硬碟。\n"}]}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"這也導致了，MySQL 不能與 PostgreSQL 一般，進行 transactions 的嵌套（nested）"},{"type":"element","tag":"sup","props":{},"children":[{"type":"element","tag":"a","props":{"href":"#user-content-fn-8","ariaDescribedBy":"footnote-label","dataFootnoteRef":true,"id":"user-content-fnref-8"},"children":[{"type":"text","value":"3"}]}]},{"type":"text","value":"，因為若在 transactions 裡又輸入 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 時，這之前的 SQL 敘述就會先被 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"COMMIT;"}]},{"type":"text","value":" 存入硬碟中。以下面程式碼（"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-5"}]},{"type":"text","value":"）為例，在 MySQL 中，"},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"First"}]},{"type":"text","value":" 是會被存入資料表的，PostgreSQL 則不會。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 3-5"}]},{"type":"text","value":"：transactions 嵌套示例"}]},{"type":"element","tag":"code","props":{"code":"CREATE TABLE log (\n    content varchar(255)\n);\n\nBEGIN;\n    INSERT INTO log (content) VALUES ('First');\n\n    BEGIN;\n        INSERT INTO log (content) VALUES ('Second');\n        ROLLBACK;\n    COMMIT;\n\n    ROLLBACK;\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"CREATE TABLE log (\n    content varchar(255)\n);\n\nBEGIN;\n    INSERT INTO log (content) VALUES ('First');\n\n    BEGIN;\n        INSERT INTO log (content) VALUES ('Second');\n        ROLLBACK;\n    COMMIT;\n\n    ROLLBACK;\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"延伸應用"},"children":[{"type":"text","value":"延伸應用"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"另外，也因為 transaction 是在整個 transaction 完成且成功的情況下才會將資料寫入硬碟，不會如同一般情況是一個敘述寫入一次（事實上，一個敘述也等同一個 transaction。），所以若遇到需要執行大量敘述時，可以透過 transaction block 包覆起來，讓全部執行完後再一次寫入硬碟，節省對硬碟做 I/O 的時間，讓執行更加快。如"},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 4-1"}]},{"type":"text","value":"："}]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"程式碼 4-1"}]},{"type":"text","value":"：大量敘述搭配 transaction 以提升效率的示例"}]},{"type":"element","tag":"code","props":{"code":"BEGIN;\nINSERT INTO users (username, password) VALUES ('USERNAME_1', 'PASSWORD_1');\nINSERT INTO users (username, password) VALUES ('USERNAME_2', 'PASSWORD_2');\n-- ...\nINSERT INTO users (username, password) VALUES ('USERNAME_1000', 'PASSWORD_1000');\nCOMMIT;\n"},"children":[{"type":"element","tag":"pre","props":{},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"BEGIN;\nINSERT INTO users (username, password) VALUES ('USERNAME_1', 'PASSWORD_1');\nINSERT INTO users (username, password) VALUES ('USERNAME_2', 'PASSWORD_2');\n-- ...\nINSERT INTO users (username, password) VALUES ('USERNAME_1000', 'PASSWORD_1000');\nCOMMIT;\n"}]}]}]},{"type":"element","tag":"h2","props":{"id":"結論"},"children":[{"type":"text","value":"結論"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"本文透過對 PostgreSQL 對每個單一敘述都使用 transaction block 包覆起來的設計，以及 transaction 代表從記憶體寫入硬碟這件事的認知，總算一解原先對該段敘述的疑惑。也透過比較 MySQL 相對應的功能的設計，更深入了解 transaction 運作上的差異。有了這些概念，日後在兩套資料庫系統交互使用時，就能避免踩到地雷了。"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"最後，也感謝 "},{"type":"element","tag":"a","props":{"href":"https://github.com/david50407","rel":["nofollow"]},"children":[{"type":"text","value":"@david50407"}]},{"type":"text","value":" 對這相關議題的講解以及 "},{"type":"element","tag":"a","props":{"href":"https://github.com/TEMU1086","rel":["nofollow"]},"children":[{"type":"text","value":"@JasonWu"}]},{"type":"text","value":" 的共同討論。"}]},{"type":"element","tag":"hr","props":{},"children":[]},{"type":"element","tag":"p","props":{},"children":[{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^1"}]},{"type":"text","value":" transaction 通常在中文會翻譯成「交易」，但為了突顯其為本文探討的核心，在本文就不翻譯了。transaction block 亦同。"}]},{"type":"element","tag":"section","props":{"className":["footnotes"],"dataFootnotes":true},"children":[{"type":"element","tag":"h2","props":{"id":"footnote-label","className":["sr-only"]},"children":[{"type":"text","value":"Footnotes"}]},{"type":"element","tag":"ol","props":{},"children":[{"type":"element","tag":"li","props":{"id":"user-content-fn-2"},"children":[{"type":"text","value":"all-or-nothing 直譯就是「全有或全無」，社群多是直接使用原文為主。另外搜尋到的中山資管所"},{"type":"element","tag":"a","props":{"href":"https://www.mis.nsysu.edu.tw/~syhwang/Courses/DB/manuscript.pdf","rel":["nofollow"]},"children":[{"type":"text","value":"資料庫系統專題課程講義"}]},{"type":"text","value":"裡面則是加註「完整的執行完畢或保持原狀都不做」。這邊為了突顯其專有名詞的意涵，刻意翻成比較文言的「全或無」，其他類似翻譯可以參照國家研究院的"},{"type":"element","tag":"a","props":{"href":"http://terms.naer.edu.tw/detail/1304408/","rel":["nofollow"]},"children":[{"type":"text","value":"雙語詞彙資訊網"}]},{"type":"text","value":"；另有「悉無律」的翻譯，但這個詞似乎比較常作為漢字在日文中使用。這方面的翻譯多用在生物學的神經衝動現象上。（我和朋友都戲稱這叫老鼠屎原則，因為只要有敘述裡如有一顆老鼠屎的錯誤發生，就得將代表整鍋粥的 transaction block 全部丟掉。比較風雅一點的戲稱就是「鼠糞原則」。）"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^3"}]},{"type":"text","value":" PostgreSQL 在 transaction block 中，若遇到錯誤，會自動丟出 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"ROLLBACK;"}]},{"type":"text","value":"。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^4"}]},{"type":"text","value":" MySQL 預設是使用 SQL 標準的 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"START TRANSACTION;"}]},{"type":"text","value":"作為 transaction 起始的宣告語法，但也支援 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN;"}]},{"type":"text","value":" 作為同義語法。"},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^5"}]},{"type":"text","value":" MySQL 在當前連線停用自動提交功能，並不會導致其他連線的自動提交也被停用。 "},{"type":"element","tag":"br","props":{},"children":[]},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"^6"}]},{"type":"text","value":" MySQL 會造成隱性提交（implicit commit）的語法："},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"BEGIN"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"LOCK TABLES"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"SET autocommit = 1"}]},{"type":"text","value":" (若原本不等於 "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"1"}]},{"type":"text","value":"時), "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"START TRANSACTION"}]},{"type":"text","value":", "},{"type":"element","tag":"code-inline","props":{},"children":[{"type":"text","value":"UNLOCK TABLES"}]},{"type":"text","value":". "},{"type":"element","tag":"a","props":{"href":"#user-content-fnref-2","ariaLabel":"Back to content","className":["data-footnote-backref"],"dataFootnoteBackref":true},"children":[{"type":"text","value":"↩"}]}]},{"type":"element","tag":"li","props":{"id":"user-content-fn-7"},"children":[{"type":"element","tag":"a","props":{"href":"https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html","rel":["nofollow"]},"children":[{"type":"text","value":"MySQL Ref 13.3.3"}]},{"type":"text","value":": The statements listed in this section (and any synonyms for them) implicitly end any transaction active in the current session, as if you had done a COMMIT before executing the statement. "},{"type":"element","tag":"a","props":{"href":"#user-content-fnref-7","ariaLabel":"Back to content","className":["data-footnote-backref"],"dataFootnoteBackref":true},"children":[{"type":"text","value":"↩"}]}]},{"type":"element","tag":"li","props":{"id":"user-content-fn-8"},"children":[{"type":"element","tag":"a","props":{"href":"https://dev.mysql.com/doc/refman/5.7/en/implicit-commit.html","rel":["nofollow"]},"children":[{"type":"text","value":"MySQL Ref 13.3.3"}]},{"type":"text","value":": Transactions cannot be nested. This is a consequence of the implicit commit performed for any current transaction when you issue a START TRANSACTION statement or one of its synonyms.  "},{"type":"element","tag":"a","props":{"href":"#user-content-fnref-8","ariaLabel":"Back to content","className":["data-footnote-backref"],"dataFootnoteBackref":true},"children":[{"type":"text","value":"↩"}]}]}]}]}]},"title_en":"Transaction Design of PostgreSQL & MySQL","slug":"transaction-design-of-postgre-sql-and-my-sql","aliases":["PostgreSQL 與 MySQL 關於 transaction 的設計理念","Transaction Design of PostgreSQL & MySQL"],"created_at":"2017-09-17T10:41:53.000Z","published_at":null,"updated_at":null,"tags":["database","mysql","postgresql"],"moc":["Information Technology"],"_type":"markdown","_id":"garden:legacy-articles:2017-09-17-transaction-design-of-postgre-sql-and-my-sql.md","_source":"garden","_file":"legacy-articles/2017-09-17-transaction-design-of-postgre-sql-and-my-sql.md","_extension":"md"}]